<template>
  <dialog-form
    v-model="showDialog"
    :title="$tc('components.program.dialogActivityEdit.title')"
    :loading="loading"
    :error="error"
    icon="mdi-calendar-plus"
    :submit-action="updateActivity"
    :submit-label="$tc('global.button.update')"
    submit-color="success"
    :cancel-action="close"
    max-width="700px"
  >
    <template #activator="scope">
      <slot name="activator" v-bind="scope" />
    </template>
    <template v-if="scheduleEntry" #moreActions>
      <v-btn
        v-if="!scheduleEntry.tmpEvent"
        color="primary"
        :to="scheduleEntryRoute(scheduleEntry)"
      >
        {{ $tc('global.button.open') }}
      </v-btn>
    </template>
    <DialogActivityForm
      :activity="entityData"
      :period="currentPeriod"
      :hide-location="hideHeaderFields"
      :hide-responsibles="hideHeaderFields"
    />
  </dialog-form>
</template>

<script>
import DialogForm from '@/components/dialog/DialogForm.vue'
import DialogBase from '@/components/dialog/DialogBase.vue'
import DialogActivityForm from './DialogActivityForm.vue'
import { scheduleEntryRoute } from '@/router.js'
import { differenceWith, intersectionWith } from 'lodash'

export default {
  name: 'DialogActivityEdit',
  components: { DialogForm, DialogActivityForm },
  extends: DialogBase,
  props: {
    scheduleEntry: { type: Object, required: false, default: null },
    activity: { type: Object, required: false, default: null },
    period: { type: Function, required: false, default: null },
    hideHeaderFields: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      entityProperties: ['title', 'location'],
      embeddedEntities: ['category'],
      initialResponsibles: [],
    }
  },
  computed: {
    scheduleEntries() {
      return this.currentActivity.scheduleEntries()
    },
    activityResponsibles() {
      return this.activity.activityResponsibles()
    },
    currentPeriod() {
      return this.period || this.scheduleEntry.period
    },
    currentActivity() {
      return this.activity || this.scheduleEntry.activity()
    },
  },
  watch: {
    showDialog: async function (showDialog) {
      if (showDialog) {
        this.loadEntityData(this.currentActivity._meta.self)

        const scheduleEntries = await this.scheduleEntries.$loadItems()
        this.$set(
          this.entityData,
          'scheduleEntries',
          scheduleEntries.items.map((scheduleEntry) => {
            return {
              period: scheduleEntry.period,
              start: scheduleEntry.start,
              end: scheduleEntry.end,
              key: scheduleEntry._meta.self,
              deleted: false,
              self: scheduleEntry._meta.self,
            }
          })
        )

        if (!this.hideHeaderFields) {
          const activityResponsibles = await this.activityResponsibles.$loadItems()
          this.initialResponsibles = activityResponsibles.items.map(
            (activityResponsible) => ({
              ...activityResponsible,
              campCollaboration: activityResponsible.campCollaboration(),
            })
          )
          this.$set(this.entityData, 'activityResponsibles', this.initialResponsibles)
        }
      }
    },
  },
  methods: {
    updateActivity() {
      this.error = null
      const _events = this._events

      const promises = this.entityData.scheduleEntries.map((entry) => {
        // deleted local entry: do nothing
        if (!entry.self && entry.deleted) {
          return Promise.resolve()
        }

        // delete existing
        if (entry.self && entry.deleted) {
          return this.api.del(entry.self)
        }

        // update existing
        if (entry.self) {
          return this.api.patch(entry.self, {
            period: entry.period()._meta.self,
            start: entry.start,
            end: entry.end,
          })
        }

        // else: create new entry
        return this.scheduleEntries.$post({
          period: entry.period()._meta.self,
          start: entry.start,
          end: entry.end,
          activity: this.currentActivity._meta.self,
        })
      })

      if (!this.hideHeaderFields) {
        const untouchedActivityResponsibles = intersectionWith(
          this.initialResponsibles,
          this.entityData.activityResponsibles,
          (a, b) => {
            return a.campCollaboration._meta.self === b.campCollaboration._meta.self
          }
        )

        const differentActivityResponsibles = differenceWith(
          [...this.initialResponsibles, ...this.entityData.activityResponsibles],
          untouchedActivityResponsibles,
          (a, b) => {
            return a.campCollaboration._meta.self === b.campCollaboration._meta.self
          }
        )

        differentActivityResponsibles.forEach((activityResponsible) => {
          if (activityResponsible?._meta?.self) {
            promises.push(this.api.del(activityResponsible._meta.self))
          } else {
            promises.push(
              this.activityResponsibles.$post({
                activity: this.currentActivity._meta.self,
                campCollaboration: activityResponsible.campCollaboration._meta.self,
              })
            )
          }
        })
      }

      // patch activity entity
      const activityPayload = { ...this.entityData }
      delete activityPayload.scheduleEntries
      delete activityPayload.activityResponsibles
      promises.push(this.api.patch(this.entityUri, activityPayload))

      // execute all requests together --> onError if one fails
      const promise = Promise.all(promises).then(this.updatedSuccessful, (e) => {
        this.onError(_events, e)
      })

      this.$emit('submit')
      return promise
    },
    updatedSuccessful(data) {
      this.close()
      this.$emit('activityUpdated', data)
    },
    scheduleEntryRoute,
  },
}
</script>

<style scoped></style>
