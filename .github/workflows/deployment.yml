name: Deploy staging or prod

on:
  repository_dispatch:
    types: [ ci-passed ]
  workflow_dispatch:       # Allow triggering manually
    inputs:
      confirmDeployWithoutCI:
        description: 'I confirm that I want to deploy without running CI first.'
        required: true
        type: boolean

jobs:
  determine-vars:
    name: Determine environment
    if: ${{ (inputs.confirmDeployWithoutCI == true) || (github.event.action == 'ci-passed' ) }}
    outputs:
      environment: ${{ steps.get-branch-name.outputs.result }}
      sha: ${{ steps.determine-sha.outputs.result }}
    runs-on: ubuntu-latest
    steps:

      - uses: actions/github-script@v6
        id: get-branch-name
        with:
          result-encoding: string
          script: |
            return (context.payload.action === 'ci-passed' ? context.payload.client_payload.ref : context.payload.ref).replace('refs/heads/', '')

      - uses: actions/github-script@v6
        id: determine-sha
        with:
          result-encoding: string
          script: |
            return (context.payload.action === 'ci-passed' ? context.payload.client_payload.sha : context.sha)

      - name: Log detected environment & sha
        run: |
          echo "${{ steps.get-branch-name.outputs.result }}"
          echo "${{ steps.determine-sha.outputs.result }}"

  build-and-push:
    name: Build and push docker images
    if: ${{ (needs.determine-vars.outputs.environment == 'staging') || (needs.determine-vars.outputs.environment == 'prod') }}
    needs: determine-vars
    uses: ./.github/workflows/reusable-build-and-push.yml
    with:
      tag: ${{ needs.determine-vars.outputs.environment }}
      sha: ${{ needs.determine-vars.outputs.sha }}
    secrets:
      DOCKER_HUB_USERNAME: ${{ vars.DOCKER_HUB_USERNAME }}
      DOCKER_HUB_PASSWORD: ${{ secrets.DOCKER_HUB_PASSWORD }}

  upgrade-or-install-deployment:
    name: Upgrade or install deployment
    if: ${{ (needs.determine-vars.outputs.environment == 'staging') || (needs.determine-vars.outputs.environment == 'prod') }}
    needs:
      - determine-vars
      - build-and-push
    runs-on: ubuntu-latest
    environment: ${{ needs.determine-vars.outputs.environment }}
    env:
      environment: ${{ needs.determine-vars.outputs.environment }}
      domain: ${{ vars.DOMAIN_SUFFIX }}.${{ vars.DOMAIN }}
    steps:
      - uses: actions/checkout@ac593985615ec2ede58e132d2e21d2b1cbd6127c # v3
        with:
          ref: ${{ needs.determine-vars.outputs.sha }}

      - name: Create a pending GitHub deployment
        uses: bobheadxi/deployments@v1.4.0
        id: deployment
        with:
          step: start
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          env: ${{ env.environment }}

      - name: Upgrade or install helm release
        run: |
          # Setup authentication
          mkdir ~/.kube && echo '${{ secrets.KUBECONFIG }}' > ~/.kube/config && chmod go-r ~/.kube/config
          # Switch to the helm chart directory
          cd .helm/ecamp3
          # Install dependency charts
          helm dependency update
          # Set the appVersion, workaround from https://github.com/helm/helm/issues/8194 so that we can
          # later find out which deployments need to be upgraded
          sed -i 's/^appVersion:.*$/appVersion: "${{ needs.determine-vars.outputs.sha }}"/' Chart.yaml
          # Install or upgrade the release
          helm upgrade --install ecamp3-${{ env.environment }} . \
            --set imageTag=${{ needs.determine-vars.outputs.sha }} \
            --set termsOfServiceLinkTemplate='https://ecamp3.ch/{lang}/tos' \
            --set domain=${{ env.domain }} \
            --set mail.dsn=${{ secrets.MAILER_DSN }} \
            --set postgresql.url='${{ secrets.POSTGRES_URL }}/${{ secrets.DB_NAME }}?sslmode=require' \
            --set postgresql.dropDBOnUninstall=false \
            --set php.dataMigrationsDir='${{ vars.DATA_MIGRATIONS_DIR }}' \
            --set php.appSecret='${{ secrets.API_APP_SECRET }}' \
            --set php.sentryDsn='${{ secrets.API_SENTRY_DSN }}' \
            --set php.jwt.passphrase='${{ secrets.JWT_PASSPHRASE }}' \
            --set php.jwt.publicKey='${{ secrets.JWT_PUBLIC_KEY }}' \
            --set php.jwt.privateKey='${{ secrets.JWT_PRIVATE_KEY }}' \
            --set php.oauth.google.clientId='${{ secrets.OAUTH_GOOGLE_CLIENT_ID }}' \
            --set php.oauth.google.clientSecret='${{ secrets.OAUTH_GOOGLE_CLIENT_SECRET }}' \
            --set php.oauth.pbsmidata.clientId='${{ secrets.OAUTH_PBSMIDATA_CLIENT_ID }}' \
            --set php.oauth.pbsmidata.clientSecret='${{ secrets.OAUTH_PBSMIDATA_CLIENT_SECRET }}' \
            --set php.oauth.pbsmidata.baseUrl='${{ secrets.OAUTH_PBSMIDATA_BASE_URL }}' \
            --set php.oauth.cevidb.clientId='${{ secrets.OAUTH_CEVIDB_CLIENT_ID }}' \
            --set php.oauth.cevidb.clientSecret='${{ secrets.OAUTH_CEVIDB_CLIENT_SECRET }}' \
            --set php.oauth.cevidb.baseUrl='${{ secrets.OAUTH_CEVIDB_BASE_URL }}' \
            --set php.oauth.jubladb.clientId='${{ secrets.OAUTH_JUBLADB_CLIENT_ID }}' \
            --set php.oauth.jubladb.clientSecret='${{ secrets.OAUTH_JUBLADB_CLIENT_SECRET }}' \
            --set php.oauth.jubladb.baseUrl='${{ secrets.OAUTH_JUBLADB_BASE_URL }}' \
            --set frontend.sentryDsn='${{ secrets.FRONTEND_SENTRY_DSN }}' \
            --set print.sentryDsn='${{ secrets.PRINT_SENTRY_DSN }}' \
            --set deploymentTime="$(date -u +%s)" \
            --set deployedVersion="$(git rev-parse --short '${{ needs.determine-vars.outputs.sha }}')" \
            --set recaptcha.siteKey='${{ secrets.RECAPTCHA_SITE_KEY }}' \
            --set recaptcha.secret='${{ secrets.RECAPTCHA_SECRET }}' \
            --set coupon.secret='${{ secrets.COUPON_SECRET }}' \
            --set frontend.loginInfoTextKey=${{ vars.LOGIN_INFO_TEXT_KEY }} \
            --set browserless.maxConcurrentSessions=${{ vars.BROWSERLESS_MAXCONCURRENTSESSIONS || 3 }} \
            --set browserless.maxQueueLength=${{ vars.BROWSERLESS_MAXQUEUELENGTH || 9 }} \
            --set browserless.resources.requests.cpu=${{ vars.BROWSERLESS_CPU || '500m' }} \
            --set browserless.resources.requests.memory=${{ vars.BROWSERLESS_MEMORY || '800Mi' }} \
            --set caddy.resources.requests.cpu=50m \
            --set caddy.resources.limits.cpu=500m \
            --set php.resources.requests.cpu=${{ vars.PHP_CPU || '1000m' }} \
            --set php.resources.requests.memory=${{ vars.PHP_MEMORY || '500Mi' }} \
            --set php.resources.limits.cpu=${{ vars.PHP_CPULIMIT || '1900m' }} \
            --set frontend.resources.requests.cpu=50m \
            --set print.resources.requests.cpu=${{ vars.PRINT_CPU || '300m' }} \
            --set print.resources.requests.memory=${{ vars.PRINT_MEMORY || '150Mi' }} \
            --set autoscaling.enabled=true \
            --set autoscaling.targetCPUUtilizationPercentage=90

      - name: Finish the GitHub deployment
        uses: bobheadxi/deployments@v1.4.0
        if: always()
        with:
          step: finish
          token: ${{ secrets.REPO_ACCESS_TOKEN }}
          status: ${{ job.status }}
          deployment_id: ${{ steps.deployment.outputs.deployment_id }}
          env_url: https://${{ env.domain }}
          env: ${{ steps.deployment.outputs.env }}
